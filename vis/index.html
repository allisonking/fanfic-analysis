<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>After All This Time?</title>
  <!-- Import D3 -->
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <!--<script src="js/d3.min.js"></script>-->

  <!-- some css -->
  <style>

  body {
    font-family: Helvetica, sans-serif;
    font-size: 14px;
  }

  .axis {
    font-family: Helvetica, sans-serif;
    font-size: 14px;
  }

  .axis text{
    fill: black;
  }

  svg text{
    font-family: Helvetica, sans-serif;
    font-size: 14px;
  }

  .label-background {
    fill: white;
    fill-opacity: .5;
  }

  .house-input {
    position: absolute;
    margin-left: 15px;
  }

  .view {
    opacity: 0.2;
    fill: white;
  }

  </style>

</head>
<body>
  Why not show your house pride? <br>
  <form class="house-input">

    <input type="radio" name="houses" value="Gryffindor" checked>Gryffindor<br>
    <input type="radio" name="houses" value="Hufflepuff">Hufflepuff <br>
    <input type="radio" name="houses" value="Ravenclaw">Ravenclaw <br>
    <input type="radio" name="houses" value="Slytherin">Slytherin
  </form>

<!-- And now for some D3! -->
<script type="text/javascript">

// set dimensions for the svg
var margin = {top: 50, right: 100, bottom: 100, left: 200};
var w = 1200 - margin.left - margin.right;
var h = 600 - margin.top - margin.bottom;

// functions to parse/format the date
var parseTime = d3.timeParse("%Y-%m-%d");
var dateToString = d3.timeFormat("%Y-%m-%d");
var dateToLabel = d3.timeFormat("%m/%d/%y")

// colors
var baseColor = 'red';
var otherColor = '#ffd700'; // gold

// create the svg
var svg = d3.select("body").append("svg")
            .attr('height', h + margin.top + margin.bottom)
            .attr('width', w + margin.left + margin.right)
          .append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

// this is used for zoom functionality- currently not working
/*var view = svg.append('rect')
              .attr('class', 'view')
              .attr('x', 0.5)
              .attr('y', 0.5)
              .attr('width', w - 1)
              .attr('height', h - 1);*/

// lightning bolt polygon
var scar = [{"x":0, "y":0},
            {"x":8,"y":0},
            {"x":-6,"y":11},
            {"x":2,"y":1},
            {"x":-6, "y":1},
            {"x":3,"y":-7}, ];
// transform it for easy access later
var newScar = scar.map(function(d) {
  return [d.x, d.y];
});

// set the ranges for the scales
var xScale = d3.scaleTime().range([0, w]);
var yScale = d3.scaleLinear().range([h, 0]);

// read in the timeline data and store as a dictionary for easy access
d3.csv("data/timeline.csv", function(timeline_data) {
  timeline_dict = {};
  timeline_data.forEach(function(d) {
    timeline_dict[parseTime(d.date)] = d.event;
  })
});

// read in the data
d3.csv("data/grouped_dates.csv", function(data) {

  // format the data from strings to their actual types
  data.forEach(function(d) {
    d.published_date = parseTime(d.published_date);
    d.count = +d.count;
  });

  // set the domain for the scale
  xScale.domain(d3.extent(data, function(d) { return d.published_date; }));
  yScale.domain([0, d3.max(data, function(d) {return d.count; })])

  // and now to draw the circles for the scatterplot
  var circles = svg.selectAll('circle')
     .data(data)
     .enter()
     .append('circle')
     // filter out the special event dates- will be scars later
     .filter(function(d) { return !timeline_dict[d.published_date] })
     .attr('cx', function(d) { return xScale(d.published_date) })
     .attr('cy', function(d) { return yScale(d.count) })
     .attr('r', 2)
     .attr('fill', baseColor)
     .on('mouseover', handleCircleMouseOver)
     .on('mouseout', handleCircleMouseOut);

  // draw the timeline events as scars
  var scars = svg.selectAll('polygon')
       .data(data)
       .enter()
       .append('polygon')
       // filter for only events
       .filter(function(d) { return timeline_dict[d.published_date]; })
       .attr('points', function(d) {
         return [newScar].join(" ");
       })
       // draw the scar and transform to where the point should be
       .attr('transform', function(d) {
         var x = xScale(d.published_date);
         var y = yScale(d.count);
         return 'translate(' + x +',' + y +')';
       })
       .attr('stroke', otherColor)
       .attr('fill', otherColor)
       .attr('stroke-width', 2)
       .on('mouseover', handleScarMouseOver)
       .on('mouseout', handleScarMouseOut);

    // add the x axis
    var xAxis = d3.axisBottom(xScale)
                  .ticks(15)
                  .tickFormat(d3.timeFormat("%Y"))

    var gX = svg.append('g')
                .attr('class', 'axis')
                .attr('transform', 'translate(0,' + h + ')')
                .call(xAxis)
                .selectAll('text') // formatting for x axis labels to be slanted
                  .style('text-anchor', 'end')
                  .attr('dx', '-.8em')
                  .attr('dy', '.15em')
                  .attr('transform', 'rotate(-65)');

    // add the y
    var yAxis = d3.axisLeft(yScale);
    var gY = svg.append('g')
                .attr('class', 'axis')
                .call(yAxis);

    // now for some titles/labels
    svg.append('text')
       .attr('text-anchor', 'middle')
       .attr('transform', 'translate(' + -margin.left/2 +',' + (h/2) +')rotate(-90)')
       .text('Number of Fan Fictions Published');
    svg.append('text')
       .attr('text-anchor', 'middle')
       .attr('transform', 'translate(' + (w/2) + ',' + (h + margin.bottom * 3/4) +')')
       .text('Date');
    svg.append('text')
       .attr('text-anchor', 'middle')
       .attr('transform', 'translate(' + (w/2) + ',' + -margin.top/2 + ')')
       .text('Harry Potter Fan Fiction Publications Over Time');

    d3.selectAll("input[name='houses']").on("change", function(){
      switch(this.value) {
        case 'Gryffindor':
          baseColor = 'red';
          otherColor = '#ffd700';
          break;
        case 'Hufflepuff':
          baseColor = 'yellow';
          otherColor = 'black';
          break;
        case 'Slytherin':
          baseColor = '#c0c0c0';
          otherColor = 'green';
          break;
        case 'Ravenclaw':
          baseColor = 'blue';
          otherColor = '#cd7f32'; //bronze
          break;
        default:
          baseColor = 'red';
          otherColor = '#ffd700';
      }
      circles.transition()
             .delay(function(d, i) {
               return i * .25;
             })
             .duration(100)
             .attr('fill', baseColor);

      scars.transition()
           .delay(function(d, i) {
             return i * 50;
           })
           .attr('stroke', otherColor)
           .attr('fill', otherColor);
    });

    // try zooming. need to update data with the axes. x axis is acting funny
    /*var zoom = d3.zoom()
                 .scaleExtent([1,40])
                 .translateExtent([[-100, -100], [w + 90, h + 100]])
                 .on("zoom", zoomed);

    svg.call(zoom);

    function zoomed() {
      svg.attr('transform', d3.event.transform);
      newXScale = xAxis.scale(d3.event.transform.rescaleX(xScale));
      gX.call(newXScale)
        .selectAll('text') // formatting for x axis labels to be slanted
        .style('text-anchor', 'end')
        .attr('dx', '-.8em')
        .attr('dy', '.15em')
        .attr('transform', 'rotate(-65)');

      newYScale = yAxis.scale(d3.event.transform.rescaleY(yScale));
      gY.call(newYScale);
      update();
    }

    function update() {
      var circle = svg.selectAll('circle')
                      .data(function(d) {
                        return d;
                      });
      //circle.enter()
    } */
});

 // function to handle when someone mouses over an event
 function handleScarMouseOver(d, i) {
   d3.select(this)
     .attr('transform', function(d) {
       var x = xScale(d.published_date);
       var y = yScale(d.count);
       return 'translate(' + x +',' + y +') scale(1.5)';
     })

     // assign the text labeling a group and ID so we can delete it later
     group = svg.append('g')
                .attr('id', 'id-'+dateToString(d.published_date));

     var text = group.append('text')
                   .attr("x", xScale(d.published_date) - 20 )
                   .attr("y", yScale(d.count) - 5)
                   .attr('text-anchor', 'middle')
                   .attr('class', 'timeline-label')
                   .text(dateToLabel(d.published_date) + ": "
                     + timeline_dict[d.published_date]);

    group.append('line')
         .attr('x1', xScale(d.published_date))
         .attr('x2', xScale(d.published_date))
         .attr('y1', yScale(0))
         .attr('y2', 0)
         .style('stroke-width', 1)
         .style('stroke', 'black');

     // get the bbox so we can place a background
     var bbox = text.node().getBBox();
     var bboxPadding = 5;

     // place the background
     var rect = group.insert('rect', ':first-child')
                   .attr('x', bbox.x - bboxPadding/2)
                   .attr('y', bbox.y - bboxPadding/2)
                   .attr('width', bbox.width + bboxPadding)
                   .attr('height', bbox.height + bboxPadding)
                   .attr('rx', 10)
                   .attr('ry', 10)
                   .attr('class', 'label-background');
 }

 // function to handle when someone mouses out of an event
 function handleScarMouseOut(d, i) {
   d3.select(this)
     .attr('transform', function(d) {
       var x = xScale(d.published_date);
       var y = yScale(d.count);
       return 'translate(' + x +',' + y +')';
     })
   d3.select('#id-'+dateToString(d.published_date)).remove();

 }

 // function to handle when user hovers over a point
 // changes color + size of circle and displays the date/number published
 function handleCircleMouseOver(d, i) {
   d3.select(this)
     .attr('fill', otherColor)
     .attr('r', 10);

   // assign the text labeling a group and ID so we can delete it later
   group = svg.append('g')
              .attr('id', 'id-'+dateToString(d.published_date));

   var text = group.append('text')
                 .attr("x", xScale(d.published_date) - 20 )
                 .attr("y", yScale(d.count) - 5)
                 .attr('text-anchor', 'middle')
                 .text(dateToLabel(d.published_date) + ": " + d.count);

   // get the bbox so we can place a background
   var bbox = text.node().getBBox();
   var bboxPadding = 5;

   // place the background
   var rect = group.insert('rect', ':first-child')
                 .attr('x', bbox.x - bboxPadding/2)
                 .attr('y', bbox.y - bboxPadding/2)
                 .attr('width', bbox.width + bboxPadding)
                 .attr('height', bbox.height + bboxPadding)
                 .attr('rx', 10)
                 .attr('ry', 10)
                 .attr('class', 'label-background');
 }

 // function to handle when user leaves a point
 // reverts back to original size + color; deletes text label group
 function handleCircleMouseOut(d, i) {
   d3.select(this)
     .attr('fill', baseColor)
     .attr('r', 2);
   d3.select('#id-'+dateToString(d.published_date)).remove();
 }

 </script>
</body>
</html>
